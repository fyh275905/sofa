# This Python scene requires the SofaPython3 plugin
#
# This scene shows the use of MechanicalMatrixMapper. A beam made of hexahedrons is simulated. One part is
# deformable, while the other is rigid.
#
# To achieve this behavior, the two parts are defined independently. The deformable part (respectively the rigid part)
# is defined with vec3 (respectively rigid) degrees of freedom. The two parts are joined as a single object using a
# mapping, which has both parts as input. The FEM is really computed in the mapped node. The deformable part is just a
# subset of the FEM degrees of freedom, while the rigid part is mapped on the rigid degree of freedom.
#
# SOFA does not transfer the mapped stiffness matrix naturally (on an assembled linear system). The FEM in the mapped
# node must be transferred to the global matrix system using MechanicalMatrixMapper. Otherwise, the derivatives of the
# FEM forces are considered null.
#

import Sofa

def createScene(rootNode):  
        rootNode.addObject('RequiredPlugin', name='Sofa.Component.Constraint.Projective') # Needed to use components [FixedConstraint]  
        rootNode.addObject('RequiredPlugin', name='Sofa.Component.Engine.Select') # Needed to use components [BoxROI]  
        rootNode.addObject('RequiredPlugin', name='Sofa.Component.LinearSolver.Direct') # Needed to use components [SparseLDLSolver]  
        rootNode.addObject('RequiredPlugin', name='Sofa.Component.Mapping.Linear') # Needed to use components [SubsetMultiMapping]  
        rootNode.addObject('RequiredPlugin', name='Sofa.Component.Mapping.MappedMatrix') # Needed to use components [MechanicalMatrixMapper]  
        rootNode.addObject('RequiredPlugin', name='Sofa.Component.Mapping.NonLinear') # Needed to use components [RigidMapping]  
        rootNode.addObject('RequiredPlugin', name='Sofa.Component.Mass') # Needed to use components [UniformMass]  
        rootNode.addObject('RequiredPlugin', name='Sofa.Component.MechanicalLoad') # Needed to use components [ConstantForceField]  
        rootNode.addObject('RequiredPlugin', name='Sofa.Component.ODESolver.Backward') # Needed to use components [EulerImplicitSolver]  
        rootNode.addObject('RequiredPlugin', name='Sofa.Component.SolidMechanics.FEM.Elastic') # Needed to use components [HexahedronFEMForceField]  
        rootNode.addObject('RequiredPlugin', name='Sofa.Component.StateContainer') # Needed to use components [MechanicalObject]  
        rootNode.addObject('RequiredPlugin', name='Sofa.Component.Topology.Container.Constant') # Needed to use components [MeshTopology]  
        rootNode.addObject('RequiredPlugin', name='Sofa.Component.Topology.Container.Grid') # Needed to use components [RegularGridTopology]  
        rootNode.addObject('RequiredPlugin', name='Sofa.Component.Visual') # Needed to use components [VisualStyle]

        rootNode.addObject('VisualStyle', displayFlags='showCollisionModels hideMappings showForceFields')

        meshDivision = rootNode.addChild('meshDivision')
        meshDivision.addObject('RegularGridTopology', name='topology', n=[8, 8, 16] , min=[-1, -1, -2], max=[1, 1, 2])
        meshOfStructure = meshDivision.addObject('MeshTopology',name='beamMesh', src="@topology")
        meshDivision.addObject('MechanicalObject', template='Vec3')
        boxDeformable= meshDivision.addObject('BoxROI',template="Vec3", name='box_roi_deformable', box=[-1, -1, -2.05, 1, 1, 1.5], position="@beamMesh.position" )
        boxRigid= meshDivision.addObject('BoxROI',template="Vec3", name='box_roi_rigid', box=[-1, -1, 1.500001, 1, 1, 2.05], position="@beamMesh.position")

        SolverNode= rootNode.addChild('SolverNode')
        SolverNode.addObject('EulerImplicitSolver', rayleighStiffness=0.1, rayleighMass=0.1)
        SolverNode.addObject('SparseLDLSolver', name="ldlsolveur")


#####   Deformable Part of the BEAM (Main Body)
        deformablePartNode= SolverNode.addChild('deformablePartNode')
        deformablePartNode.addObject('MechanicalObject', template='Vec3',name='beamPart1Mech', position="@"+boxDeformable.getPathName()+".pointsInROI")
        deformablePartNode.addObject('BoxROI',template="Vec3", name='box_roi_fix', box=[-1, -1, -2.05,  1, 1, -1.5], position="@beamPart1Mech.position" )
        deformablePartNode.addObject('FixedConstraint', indices='@box_roi_fix.indices')

#####   Rigid Part of the BEAM (Top)
        RigidNode= SolverNode.addChild('RigidNode')
        RigidNode.addObject("MechanicalObject",template="Rigid3",name="rigid1", position=[0, 0, 2,  0, 0, 0, 1], showObject=True, showObjectScale=0.5)
        RigidifiedNode= RigidNode.addChild('RigidifiedNode')

        RigidifiedNode.addObject("MechanicalObject",name="rigidMecha",template="Vec3", position="@"+boxRigid.getPathName()+".pointsInROI")
        RigidifiedNode.addObject("RigidMapping",globalToLocalCoords="true")

#####   COMBINED BEAM
        FEMNode= deformablePartNode.addChild('FEMNode')
        RigidifiedNode.addChild(FEMNode)

        FEMNode.addObject('MeshTopology',name='meshInput',src="@"+meshOfStructure.getPathName())
        FEMNode.addObject('MechanicalObject', template='Vec3',name='beamMecha')
        FEMNode.addObject('HexahedronFEMForceField', name='HexaFF', src="@meshInput", poissonRatio=0.49, youngModulus=2000)
        FEMNode.addObject('UniformMass', totalMass=0.1)

        FEMNode.addObject('BoxROI', name='corner', box=[1, 1, 2, 1, 1, 2])
        FEMNode.addObject('ConstantForceField', name='xMoins', indices='@corner.indices', forces=[1000, 0, 0])


        meshDivision.init()
        boxDeformable.init()
        boxRigid.init()
        index_pairs = [ [0, 0] ] * len(meshOfStructure.position)

        i = 0
        for index in boxDeformable.indices.value:
                index_pairs[index] = [0, i]
                i += 1
        i = 0
        for index in boxRigid.indices.value:
                index_pairs[index] = [1, i]
                i += 1

        FEMNode.addObject("SubsetMultiMapping",name="subsetMapping",template="Vec3,Vec3",
                          input="@../beamPart1Mech @../../RigidNode/RigidifiedNode/rigidMecha",
                          output="@./beamMecha",
                          indexPairs=index_pairs)

        return rootNode

