<html>
<head>
<link href="../../../Objects/sofa_white.css" rel="stylesheet" type="text/css" />
</head>
<body>
	<div id="contenu">
		
		<center><h3>Creation of a Scene (7/9)</h3></center>
		<center><img src="6_FullObject.png" width="300" name="FullObject" align="middle"></center>
		
		<br><div id="orangeText">Description</div><br>

		Like we did in <a href="4_FullObject.scn">this part</a> of the tutorial, we will map another model to the simulated mechanical object.
		This time, it won't be only a visual model, but a mechanical object which aims at handling the collisions, and to transmit the forces due to the collision response to the simulated object. <br>
                Once this model is able to transmit the forces, we just need to add some collision models like we did <a href="5_FullObject.scn">here </a><br>
                Remember:
                <ul>
                  <li> <u>Visual Mapping</u>: the information is passed Top-Down: the simulated object propagates the positions  <i>(method apply) </i> and the velocities <i>(method applyJ)</i> to the mapped model</li>
                  <li> <u>Mechanical Mapping</u>: the information is passed both ways: the simulated object propagates the positions  <i>(method apply) </i> and the velocities  <i>(method applyJ) </i> to the mapped model, and on th eother site, the mapped model propagates the forces to the simulated object  <i>(method applyJT) </i></li>
                </ul>


		<br><div id="orangeText">Key points</div><br>
                We create a new node containing the collision object: we need to load the model from a mesh file. Thus, we will use the <b>MeshTopology</b>, using the parameter "fileTopology" to specify the file. As a first example we use a cube as collision object.<br>
                Then, we need a MechanicalObject to store the positions, velocities and forces of the collision object.<br>
                The collision object is mapped to the simulated deformable model using a Mapping, this time a MechanicalMapping: <b>BarycentricMapping</b>.<br> 
                <br>You may wonder what is the difference between this mapping and the one used for the visual model, as we are using the same component! what makes a mapping visual or mechanical?<br>
                This is determined by the template used to create the mapping: if you open the MechanicalMapping, and go to the tabulation "infos" you can read:<br>

                <i>Template: MechanicalMapping  &lt;Vec3d, Vec3d &gt;</i><br>
                 It means it transforms a state expressed by Vec3d types into Vec3d: <u>REMEMBER</u>, collision models are only expressed in Vec3d type, so the mapped state <u>MUST</u> be of Vec3d types.<br>
                <br>Finally, you need to specify where can be found the two mechanical states using the parameters "object1" and "object2". By default they provide a mapping from the mechanical state placed above ("../.."), to the mechanical state of the current node ("..").

		<br><div id="orangeText">Results</div><br>
		You can see height spheres, corresponding to the height corners of the cube chosen to represent our collision model. Of course, height spheres to do the collision detection is much faster than 171 as in the previous scene. But, the behaviour is much different too. If you apply a force on one of the spheres using the mouse, you will be able to deform the object: this is due to the MechanicalMapping. <br>
                <br>We displayed some debug information about the mechanical mapping using blue lines: <br>Each point of the collision model depends on several points of the simulated object. That is to says, if a force is applied to one of the collision model's point, this last one will propagate the force to all the points it depends on.
                

                <br><center><h3><a href="5_FullObject.scn">Previous</a> ____________  <a href="7_FullObject.scn">Next</a></center></h3>
	</div>
</body>
</html>
