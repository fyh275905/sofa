########################################################################
# SOFA build system configuration
#   This file should be included at the very beginning of each pro file
########################################################################

defineReplace(normalizePath) {
	path = $$1
	path = $$replace(path, //, /)
	path = $$replace(path, /$, )
	return($$path)
}

########################################################################
# Fixed variables (no customization possible)
########################################################################

PLUGINS_PATH = applications/plugins
SRC_FEATURES_PATH = features/sofa
INSTALL_INC_PATH = include/sofa
INSTALL_LIB_PATH = lib
INSTALL_BIN_PATH = bin

########################################################################
# Build system path variables
#		Warning: trying to modify these variables is pointless, they just
#		describe where the build system is running.
########################################################################

FEATURES_DIR = $$normalizePath($$PWD)
BUILD_DIR = $$normalizePath($$OUT_PWD)
SRC_DIR   = $$normalizePath($$_PRO_FILE_PWD_)

equals(BUILD_DIR, $$SRC_DIR) {
	OUT_OF_SOURCE = false
} else {
	OUT_OF_SOURCE = true
}

# We could get the ROOT_BUILD_DIR on Unix using $$(PWD), but
# on Windows the equivalent $$(CD) does not work and $$system(echo %CD%)
# gives the same path as $$PWD which is not the root build directory.
# We have to compute what piece of path is common to both the BUILD_DIR
# and the SRC_DIR and deduce the root build directory.
# We have chosen to use a common approach for both platform, because it
# makes it easier to compute derivate paths: SUBDIR_PATH and ROOT_PATH.

equals(OUT_OF_SOURCE, true) {
	# Out-of-source build.
	ROOT_SRC_DIR   = $$SRC_DIR
	ROOT_BUILD_DIR = $$BUILD_DIR
	DIR_LIST = $$split(SRC_DIR, '/')
	# We iterate on path elements.
	# Each iteration will discard the last element of each path
	# until they get different. At this moment the remaining paths
	# will only contain the root source dir and the root build dir.
	for(dir, DIR_LIST) {
		sdir = $$basename(ROOT_SRC_DIR)
		bdir = $$basename(ROOT_BUILD_DIR)
		equals(sdir, $$bdir) {
			# Prepend the directory to the path of the subdir
			isEmpty(SUBDIR_PATH): SUBDIR_PATH = $$sdir
			else:                 SUBDIR_PATH = $$sdir/$$SUBDIR_PATH
			isEmpty(ROOT_PATH):   ROOT_PATH = ..
			else:                 ROOT_PATH = $$ROOT_PATH/..
			# Remove the last element of the directory lists
			ROOT_SRC_DIR = $$dirname(ROOT_SRC_DIR)
			ROOT_BUILD_DIR = $$dirname(ROOT_BUILD_DIR)
		} else {
			break()
		}
	}
	isEmpty(SUBDIR_PATH):    SUBDIR_PATH = .
	isEmpty(ROOT_PATH):      ROOT_PATH = .
	isEmpty(ROOT_SRC_DIR):   ROOT_SRC_DIR = .
	isEmpty(ROOT_BUILD_DIR): ROOT_BUILD_DIR = .
} else {
	# In-source build.
	unix {
		ROOT_BUILD_DIR = $$(PWD)
		ROOT_SRC_DIR = $$(PWD)
	} else {
		# HACK: On windows we have no other choice but to make assumptions about the
		# names of the source directories to deduce the root source directory.
	  ROOT_SRC_DIR   = $$replace(SRC_DIR, (.+)/(applications|extlibs|framework|modules)(/.+)?, \\1)
		ROOT_BUILD_DIR = $$ROOT_SRC_DIR
	}
	SUBDIR_PATH = $$replace(BUILD_DIR, $$ROOT_BUILD_DIR, .)
	SUBDIR_PATH = $$replace(SUBDIR_PATH, ^\\./,)

	ROOT_PATH = $$replace(SUBDIR_PATH, [^/]+/, ../)
	ROOT_PATH = $$replace(ROOT_PATH, \\w+, ..)
}

#message(ROOT_SRC_DIR  $$escape_expand(\\t)= $$ROOT_SRC_DIR)
#message(SRC_DIR       $$escape_expand(\\t)= $$SRC_DIR)
#message(ROOT_BUILD_DIR$$escape_expand(\\t)= $$ROOT_BUILD_DIR)
#message(BUILD_DIR     $$escape_expand(\\t)= $$BUILD_DIR)
#message(SUBDIR_PATH   $$escape_expand(\\t)= $$SUBDIR_PATH)
#message(ROOT_PATH     $$escape_expand(\\t)= $$ROOT_PATH)

########################################################################
# Extension point:
#		If needed, create a file name sofa/pre-custom.prf at the root of
#		your build dir (where you run qmake), and set any variable you need.
#		Values defined there will override default values.
#		If you run "make install" this file will be installed.
########################################################################

CUSTOM_FEATURES_FILE = $$ROOT_BUILD_DIR/sofa-local
INSTALLED_FEATURE_FILE = $$FEATURES_DIR/sofa-local

exists($${CUSTOM_FEATURES_FILE}.prf) {
	load($$CUSTOM_FEATURES_FILE)
}

exists($${INSTALLED_FEATURE_FILE}.prf) {
	load($$INSTALLED_FEATURE_FILE)
}

########################################################################
# Load SOFA-specific configuration
########################################################################

load($$FEATURES_DIR/config-pre)

########################################################################
# Descriptive variables
########################################################################

*-32*|win32* {
  # message("32 bits target")
  TARGET_ARCH=32
} else {
  *-64*|win64* {
    # message("64 bits target")
    TARGET_ARCH=64
  } else {
    contains(QMAKE_HOST.arch, x86_64) {
      # message("64 bits target (host default)")
      TARGET_ARCH=64
    } else {
      # message("32 bits target (host default)")
      TARGET_ARCH=32
    }
  }
}

CONFIG(release, debug|release) {
	CONFIGDEBUG = release
} else {
	CONFIGDEBUG = debug
}

contains(QMAKE_CXXFLAGS, -pg) {
  CONFIGDEBUG += profile
}

########################################################################
# Some configuration variables
########################################################################

contains(CONFIGDEBUG, debug) {
	LIBSUFFIX = d
	APPSUFFIX = d
}
contains(CONFIGDEBUG, profile) {
	APPSUFFIX = $${APPSUFFIX}p
}

########################################################################
# Definition of Qt standard paths for intermediate files
########################################################################

# Only define these directories when performing an in-source build.
isEqual(BUILD_DIR, $$SRC_DIR) {
	isEmpty(OBJECTS_DIR) {
		OBJECTS_DIR = OBJ/$$CONFIGDEBUG
	}
	
	isEmpty(RCC_DIR) {
		RCC_DIR = RCC
	}
	
	isEmpty(MOC_DIR) {
		MOC_DIR = MOC
	}
	
	isEmpty(UI_DIR) {
		UI_DIR = UI
	}
}

########################################################################
# Detection of SOFA-specific paths
########################################################################

SRC_FEATURES_DIR = $$ROOT_SRC_DIR/$$SRC_FEATURES_PATH

isEmpty(INSTALL_DIR) {
	INSTALL_DIR = /usr
}

equals(FEATURES_DIR, $$SRC_FEATURES_DIR) {
	USING_INSTALL = false
} else {
	USING_INSTALL = true
	
	SOFA_INSTALL_DIR = $$replace(FEATURES_DIR, ^(.*$${INSTALL_DIR})/.+$, \\1)
	isEmpty(SOFA_INSTALL_DIR): error(Unable to detect the install dir (maybe it has been moved since install, or some .prf file have been deleted))	
}


QMAKE_MKSPECS = $$[QMAKE_MKSPECS]
match = $$find(QMAKE_MKSPECS, ^$${INSTALL_DIR}.*$)
isEmpty(match) {
	warning(Feature files will not be installed in Qt standard directory; so you will have to set QMAKEFEATURES environment variable to use them.)
	INSTALL_PRF_PATH = share/sofa/$$$$SRC_FEATURES_PATH
} else {
	INSTALL_PRF_PATH = $$replace(QMAKE_MKSPECS, ^$$INSTALL_DIR/(.+), \\1)/$$SRC_FEATURES_PATH
}

########################################################################
# Customizable parameters
########################################################################

isEmpty(PACKAGE) {
	PACKAGE = sofa
}

isEmpty(RELEASE) {
	RELEASE = 1.0.0
}

isEmpty(DIST_DIR) {
	DIST_DIR = $$ROOT_BUILD_DIR/$$PACKAGE-$$RELEASE
}

isEmpty(CONFIGSTATIC) {
	CONFIGSTATIC = shared
}

isEmpty(LIB_DESTDIR) {
	LIB_DESTDIR = $$ROOT_PATH/lib
}

isEmpty(APP_DESTDIR) {
	APP_DESTDIR = $$ROOT_PATH/bin
}

########################################################################
# Definition of derived paths
########################################################################

# Define the target directories for installation
INSTALL_INC_DIR = $$INSTALL_DIR/$$INSTALL_INC_PATH
INSTALL_LIB_DIR = $$INSTALL_DIR/$$INSTALL_LIB_PATH
INSTALL_BIN_DIR = $$INSTALL_DIR/$$INSTALL_BIN_PATH
INSTALL_PRF_DIR = $$INSTALL_DIR/$$INSTALL_PRF_PATH

# Defines directories where the installed version of Sofa is
equals(USING_INSTALL, true) {
	SOFA_INSTALL_INC_DIR = $$SOFA_INSTALL_DIR/$$INSTALL_INC_PATH
	SOFA_INSTALL_LIB_DIR = $$SOFA_INSTALL_DIR/$$INSTALL_LIB_PATH
} else {
	SOFA_INSTALL_INC_DIR = $$ROOT_SRC_DIR
}

########################################################################
# Utility functions
########################################################################

defineTest(addCommand) {
	cmdvar = $$1
	command = $$2
	isEmpty($$cmdvar) {
		$$cmdvar = $$command
	} else {
		$$cmdvar += $$escape_expand(\\n\\t)$$command
	}
	export($$cmdvar)
}

########################################################################
# Dependency management functions
########################################################################

##
# This function allows to protect a block from being parsed more than once in
# the include tree.
#
# Parameters:
#		name		a unique name associated with this block (eg: using $$__FILE__ as
#						argument will ensure this block will only be read once for the given file)
#
defineTest(includeOnce) {
	projectFile = $$basename(1)
	projectName = $$replace(projectFile, \\., _)

	defined = $$eval($${projectFile}.defined)
	path = $$eval($${projectFile}.path)

	equals(defined, true) : equals(path, $$_PRO_FILE_) {
		return(false)
	} else {
		eval($${projectFile}.defined = true)
		eval($${projectFile}.path = $$_PRO_FILE_)
		export($${projectFile}.defined)
		export($${projectFile}.path)
		return(true)
	}
}

defineTest(isProjectFile) {
	path = $$eval($$1)
	match = $$find(path, ^.+\\.pro$)
	isEmpty(match) {
		return(false)
	} else {
		return(true)
	}
}

defineTest(isFeatureFile) {
	path = $$eval($$1)
	match = $$find(path, ^.+\\.prf$)
	isEmpty(match) {
		return(false)
	} else {
		return(true)
	}
}

defineReplace(canonicalize) {
	filelist = $$1
	filelist = $$replace(filelist, "/{2,}", /)
	filelist = $$replace(filelist, /\\.\\.(?=/), /@)
	for(iteration, 1..100) {
		newfilelist = $$replace(filelist, /[^@/]+/@(?=/), )
		equals(filelist, $$newfilelist) {
			filelist = $$newfilelist
			break()
		}	else {
			filelist = $$newfilelist
		}
	}
	return($$filelist)
}

defineTest(addSubdirs) {
	for(subdirs, 1) {
		entries = $$files($$subdirs)
		for(entry, entries) {
			name = $$replace(entry, [/\\\\\\.], _)
			SUBDIRS += $$name
			isProjectFile(entry) {
				eval  ($${name}.file = $$entry)
				export($${name}.file)
			} else {
				eval  ($${name}.subdir = $$entry)
				export($${name}.subdir)
			}

			for(dep, 2) {
				eval ($${name}.depends += $$replace(dep, [/\\\\\\.], _))
			}
			export($${name}.depends)
		}
	}
	export(SUBDIRS)
}

##
# This functions tests whether a module is installed.
# A module is considered installed if a feature file having the specified name
# exists in the feature directory (which also contain this sofa/pre.prf file).
#
defineTest(isInstalled) {
	name = $$1
	exists($$FEATURES_DIR/$${name}.prf) {
		return (true)
	}	else {
		return (false)
	} 
}

defineTest(isExternal) {
	name = $$1
	isFeatureFile($${name}.project) {
		return(true)
	} else {
		return(false)
	}
}

##
# This function tests whether sources of the specified module are available.
# Sources are considered available if a project file having the specified name
# exists in the specified directory.
#
defineTest(isSourceAvailable) {
	name = $$1
	project  = $$2
	isFeatureFile(project) | isProjectFile(project) {
		test_path = $$ROOT_SRC_DIR/$$project
	} else {
		dir = $$project 
		proname = $$basename(project).pro
		test_path = $$ROOT_SRC_DIR/$$dir/$$proname
	}
	exists($$test_path) {
		return (true)
	}	else {
		return (false)
	}
}

##
# This function activates the compilation of the specified artifact if available.
# If it is not available for compilation it looks for an installed version, and
# will complains if the artifact is missing.
#
defineTest(addInstallableSubdir) {
	name = $$1
	dir  = $$2
	deps = $$3
	isSourceAvailable($$name, $$dir) {
		addSubdirs($$dir, $$deps)
	} else {
		!isInstalled($$name) {
			error(addInstallableSubdir: Cannot find $$name library)
		}
	}
}

##
# This function configures the current artifact build parameters to compile and
# link using the specified library installed on the system.
# A feature file must describe the build parameters, it can be local or installed. 
#
# Parameters:
#		name		the name of the library
#		feature	the path to the feature file relative to the root source directory.
#
# The feature file can directly modify INCLUDEPATH and LIBS variables. If other
# variables needs to be modified, the feature file will have to call export(VAR)
# on them.
defineTest(requireLib) {
	name = $$1
	feature = $$2
	isEmpty(name)   : error(missing name parameter in requireLib)
	isEmpty(feature): error(missing feature parameter in requireLib)

	message(Using system lib $$name)

	featureNoExt = $$replace(feature, ^(.+)\\.prf$, \\1)
	isSourceAvailable($$name, $$feature) {
		dir = $$dirname(feature)
		MY_FEATUREFILE = $$ROOT_SRC_DIR/$$featureNoExt
	} else {
		!isInstalled($$name) {
			error(requireLib: Cannot feature file for $$name)
		}
		MY_FEATUREFILE = $$FEATURES_DIR/$$basename(featureNoExt)
	}
	load($$MY_FEATUREFILE)

	export(INCLUDEPATH)
	export(LIBS)
}

##
# This function configures the current artifact build parameters to compile and
# link using the specified library.
# It can work either when sources are available in the same source tree as the
# client artifact, or when just the installed version is available.
#
# Parameters:
#		name	the name of the library
#		dir		the subdirectory from include tree root and/or source tree root
#
# This function makes several assumption by default to configure the include path,
# library path and library name. Nevertheless, you can customize things in the
# library feature file. This file should be named <name>.prf file and created in
# the  <dir> directory of your source tree.
# In this file, you can set MY_INCLUDEPATH, MY_LIBRARYPATH and MY_LIBS variables
# to override default values. You can also define other variables, but you
# will have to export them using export(VAR)
#
defineTest(requireExtLib) {
	name = $$1
	project  = $$2
	isEmpty(name)   : error(missing name parameter in requireExtLib)
	isEmpty(project): error(missing project parameter in requireExtLib)

	OLD_INCLUDEPATH = $$INCLUDEPATH
	OLD_LIBS = $$LIBS

	isProjectFile(project) | isFeatureFile(project) {
		dir = $$dirname(project)
	} else {
		dir = $$project
	}

	isSourceAvailable($$name, $$project) {
		message(Using shipped version of $$name)
		MY_FEATUREFILE = $$ROOT_SRC_DIR/$$dir/$${name}
		MY_INCLUDEPATH = $$ROOT_SRC_DIR/$$dir
		MY_LIBRARYPATH = -L$$LIB_DESTDIR
	} else {
		!isInstalled($$name) {
			error(requireExtLib: Cannot find $$name library)
		}
		message(Using installed version of $$name)
		MY_FEATUREFILE = $$FEATURES_DIR/$${name}
		MY_INCLUDEPATH = $$SOFA_INSTALL_INC_DIR/$$dir
		MY_LIBRARYPATH = -L$$SOFA_INSTALL_LIB_DIR
	}
	MY_LIBS = -l$$name$$LIBSUFFIX

	load($$MY_FEATUREFILE)

	equals(OLD_INCLUDEPATH, $$INCLUDEPATH) {
		INCLUDEPATH *= $$MY_INCLUDEPATH
	}
	equals(OLD_LIBS, $$LIBS) {
		LIBS *= $$MY_LIBRARYPATH $$MY_LIBS
	}

	export(INCLUDEPATH)
	export(LIBS)
}

##
# This function configures the current artifact build parameters to compile and
# link using the specified SOFA library.
# It can work either when sources are available in the same source tree as the
# client artifact, or when just the installed version is available.
#
# Parameters:
#		name	the name of the library
#		dir		the subdirectory from include tree root and/or source tree root
#
defineTest(requireSofaLib) {
	name = $$1
	project = $$2
	isEmpty(name)   : error(missing name parameter in requireSofaLib)
	isEmpty(project): error(missing project parameter in requireSofaLib)

	sourcedir = $$replace(project, (applications|framework|modules)/.+, \\1)

	isSourceAvailable($$name, $$project) {
		message(Using shipped version of Sofa library: $$name)
		INCLUDEPATH *= $$ROOT_SRC_DIR/$$sourcedir
		LIBS *= -L$$LIB_DESTDIR
	} else {
		message(Using installed version of Sofa library: $$name)
		INCLUDEPATH *= $$SOFA_INSTALL_INC_DIR/$$sourcedir
		LIBS *= -L$$SOFA_INSTALL_LIB_DIR
	}
	LIBS *= -l$$name$$LIBSUFFIX

	export(INCLUDEPATH)
	export(LIBS)
}

##
# This function declares the existence of an artifact to the dependency manager.
# The artifact can be built from sources or just be an installed library. In the
# latter case it will not need dependencies, but the project path (relative to
# the root of the install include directory) will still be needed.
#
# Parameters:
#   name		the name of the artifact. It must match the TARGET variable in the pro file.
#		project	the path to the project file folder from the source root (or the
#			project file itself if it does not have the same name as its directory
#			(which is the default, recommended in Qt))
#		dependencies	a list of the name of other artifacts, also declared with this
#			function. Declaration order does not matter: the name of a dependent
#			artifact can be used before it is declared.
#
defineTest(declare) {
	artifact = $$1
	project = $$2
	dependencies = $$3

	eval($${artifact}.name = $$artifact)
	eval($${artifact}.project = $$project)
	eval($${artifact}.deps = $$dependencies)
	eval($${artifact}.enabled = false)
	artifacts_registry += $$artifact

	export($${artifact}.name)
	export($${artifact}.project)
	export($${artifact}.deps)
	export($${artifact}.enabled)
	export(artifacts_registry)
}

defineTest(include-declarations) {
	name = $$1
	directory = $$2

	exists($$FEATURES_DIR/$${name}.prf) {
		load($$FEATURES_DIR/$$name)
	}
	else : exists($$ROOT_SRC_DIR/$${name}.prf) {
		load($$ROOT_SRC_DIR/$$name)
	}
	else : !isEmpty(directory) : exists($$ROOT_SRC_DIR/$$directory/$${name}.prf) {
		load($$ROOT_SRC_DIR/$$directory/$$name)
	}
	else : error(include-declarations: cannot find $$name (dir: $$directory))
}

##
# This function returns the list of dependencies (including transitive ones) for
# the specified artifact.
#
# Parameters:
#		name	the name of the artifact
#
defineReplace(computeTransitiveDependencies) {
	name = $$1

	# Transitive dependencies involves recursivity but recursive functions does
	# not work in qmake so we implement recursivity using a (pseudo) queue.
	# Usually we loop until the queue is empty but while loops are not
	# supported either so we use an iterative approach with 2 lists instead of a
	# queue, and 2 nested for loops instead of a while loop.
	# Maximum recursivity has to be arbitrarily defined, here we set it to 100.
	queue = $$name
	for(depth, 1..100) {
	  isEmpty(queue): break() # Stop looping when there is no more dependencies
	  # Loop on the current queue. A new queue will be filled for the next iteration.
		for(dep, queue) {
			# Ignore already analysed dependencies (to break circular dependencies)
			!contains(analysed, $$dep) {
				!equals(dep, $$eval($${dep}.name)) {
					error(computeTransitiveDependencies: undeclared artifact $$dep)
				}
				deps = $$eval($${dep}.deps) # Retrieve the dependencies of the current artifact
				newqueue *= $$deps					# Fill the next queue with these dependencies
				tdeps *= $$deps							# Add them to the list of transitive dependencies
				analysed *= $$dep						# Add the current artifact to the list of analysed ones
			}
		}
		# Switch queues
		queue = $$newqueue
		newqueue = 
	}
	return($$tdeps)
}

##
# This function enables the compilation of the specified artifact.
#
# Parameters:
#		name	the name of the artifact (use "declare" first)
#
defineTest(enable) {
	name = $$1
	eval($${name}.enabled = true)
	export($${name}.enabled)
}

##
# This function disables the compilation of the specified artifact.
#
# Parameters:
#		name	the name of the artifact (use "declare" first)
#
defineTest(disable) {
	name = $$1
	eval($${name}.enabled = false)
	export($${name}.enabled)
}

##
# This function generates the SUBDIRS configuration to build all enabled artifacts
# in the right order, using dependencies informations.
#
# Parameters:
#		none
#
defineTest(buildEnabledArtifacts) {
	for(artifact, artifacts_registry) {
		equals($${artifact}.enabled, true) {
			clear(deps_dirs)
			clear(tdeps)
			tdeps = $$computeTransitiveDependencies($$artifact)

			#message(enabling $$artifact with the following dependencies:)
			for(dep, tdeps) {
				equals($${dep}.enabled, true) {
					#message($$escape_expand(\\t)$$dep)
					dep_project = $$eval($${dep}.project)
					!isFeatureFile(dep_project) {
						deps_dirs += $$dep_project
					}
				}
			}

			project = $$eval($${artifact}.project)
			addInstallableSubdir($$artifact, $$project, $$deps_dirs) 
		}
	}
}

##
# This function loads all declared dependencies for the current artifact.
# It will set the include path, the library path, and the library list to use
# all these dependencies.
#
# Parameters:
#   name the name of the current artifact
#   recursivity if the value is "transitive" it will also load transitive dependencies
#
defineTest(loadDependencies) {
	target = $$1
	rec = $$2
	isEqual(rec, transitive) {
		dependencies = $$computeTransitiveDependencies($$target)
	} else {
		dependencies = $$eval($${target}.deps)
	}
	for(dep, dependencies) {
		name = $$eval($${dep}.name)
		!equals(dep, $$name): error(undeclared dependency $$dep)
		project = $$eval($${dep}.project)
		isFeatureFile(project) {
			requireLib($$name, $$project)
		} else {
			equals($${dep}.enabled, true) {
				sofasrc = $$find(project, ^applications|framework|modules/.+$)
				isEmpty(sofasrc) {
					requireExtLib($$name, $$project)
				} else {
					requireSofaLib($$name, $$project)
				}
			}
		}
	}
}

##
# This function should be used in dependency files to declare that the current
# artifact depends on the specified list of plugins
#
defineTest(dependOnPlugins) {
	pluginDependencies = $$1
	export(pluginDependencies)
}

##
# This function imports all the declarations necessary to use or build the specified plugin.
#
defineTest(usePlugin) {
	queue = $$1
	for(depth, 1..100) {
		isEmpty(queue): break()

		for(plugin, queue) {
			!contains(analysed, $$plugin) {
				include-declarations($${plugin}-dependencies, $$PLUGINS_PATH/$$plugin)
				newqueue *= $$pluginDependencies
				clear(pluginDependencies)
				analysed *= plugin
			}
		}
		queue = $$newqueue
		clear(newqueue)
	}
	export(pluginDependencies)
}

##
# This function configures the current project file to build an artifact belonging
# to the specified plugin.
#
defineTest(defineAsPlugin) {
	PLUGIN_NAME = $$1
	TEMPLATE = lib
	usePlugin($$PLUGIN_NAME)
	export(TEMPLATE)
	export(PLUGIN_NAME)
}

########################################################################
# Loading dependencies declarations
########################################################################

include-declarations(sofa-dependencies)

