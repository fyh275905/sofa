########################################################################
# SOFA build system configuration
#   This file should be included at the end of each pro file 
########################################################################

!contains(TEMPLATE, subdirs) {
	loadDependencies($$TARGET, transitive)
}

BUILD_SYSTEM_FILES = \
	$$SOFA_FEATURES_PATH/sofa-pre.prf \
	$$SOFA_FEATURES_PATH/sofa-post.prf

########################################################################
# Load SOFA-specific configuration
########################################################################

load($$FEATURES_DIR/sofa-config-post)

########################################################################
# Definition of artifacts directories and name
########################################################################

contains(TEMPLATE, lib) | contains(TEMPLATE, vclib) {
	DESTDIR = $$LIB_DESTDIR
}
contains(TEMPLATE, app) | contains(TEMPLATE, vcapp) {
	DESTDIR = $$APP_DESTDIR
}

contains(TEMPLATE, lib) | contains(TEMPLATE, vclib) {
	SUFFIX = $$LIBSUFFIX
}
contains(TEMPLATE, app) | contains(TEMPLATE, vcapp) {
	SUFFIX = $$APPSUFFIX
}
!isEmpty(SUFFIX) {
	TARGET = $$TARGET$$SUFFIX
}

isEmpty(OBJMOC) {
	contains(TEMPLATE, vclib) | contains(TEMPLATE, vcapp) {
	} else {
		unset(MOC_DIR)
	}
}

win32 {
	contains(TEMPLATE, lib) | contains(TEMPLATE, vclib) {
		CONFIG += static
		# TODO: support for shared libraries
	}
}

########################################################################
# Definition of make install
########################################################################

contains(TEMPLATE, lib) {
	INSTALLS += target headers features
	target.path    = $$SOFA_INSTALL_ROOT/lib
	headers.files  = $$HEADERS
	headers.path   = $$SOFA_INSTALL_ROOT/include/sofa/$$SUBDIR_PATH
	features.files = $${TARGET}.prf
	features.path  = $$SOFA_INSTALL_ROOT/$$SOFA_FEATURES_PATH
}

contains(TEMPLATE, app) {
	INSTALLS += target
	target.path = $$SOFA_INSTALL_ROOT/bin/
}

equals(ROOT_PATH, .) {
	# If the build system features files exist in the source dir, we install them.
	exists($$ROOT_SRC_DIR/$$SOFA_FEATURES_PATH) {
		INSTALLS += features
		features.files = \
			$$BUILD_SYSTEM_FILES \
			$$ROOT_BUILD_DIR/sofa-pre-custom.prf
		features.path = $$SOFA_INSTALL_ROOT/$$SOFA_FEATURES_PATH
	}
}

########################################################################
# Definition of make dist
########################################################################

# "dist" target already exists in qmake but behaves incorrectly
# We have to create another target
QMAKE_EXTRA_TARGETS += fulldist

# We distribute the .pro file and any file listed in DISTFILES (standard qmake variable)
# All filenames in DIST_FILES must be relative to the root source directory,
# that's why we append SUBDIR_PATH to local filenames defined in each .pro
PRO_FILE = $$normalizePath($$_PRO_FILE_)
DIST_FILES  = $$replace(PRO_FILE, $$ROOT_SRC_DIR/, )
DIST_FILES += $$join(DISTFILES, " $$SUBDIR_PATH/", $$SUBDIR_PATH/)

fulldist.files = $$basename(PRO_FILE) $$DISTFILES

contains(TEMPLATE, subdirs) {
	fulldist.CONFIG = recursive
} else {
	# SOURCES and HEADERS declared in each pro files are also distributed
	DIST_FILES += $$join(SOURCES, " $$SUBDIR_PATH/", $$SUBDIR_PATH/)
	DIST_FILES += $$join(HEADERS, " $$SUBDIR_PATH/", $$SUBDIR_PATH/)
	fulldist.files += $$SOURCES $$HEADERS
}

# Each makefile will copy the files it knows in the DIST_DIR, recreating a
# parallel directory hierarchy.
addCommand(fulldist.commands, $(CHK_DIR_EXISTS) $$DIST_DIR || $(MKDIR) $$DIST_DIR)
addCommand(fulldist.commands, (cd $$ROOT_SRC_DIR && rsync -R $$DIST_FILES $$DIST_DIR))

# In the root makefile, we copy feature files, pack everything and remove the DIST_DIR
equals(ROOT_PATH, .) {
	# We override the dist target that should not exist at the root if it is a
	# recursive project.
	contains(TEMPLATE, subdirs) {
		QMAKE_EXTRA_TARGETS += dist
		dist.depends = fulldist
	}
	exists($$ROOT_SRC_DIR/$$SOFA_FEATURES_PATH) {
		addCommand(fulldist.commands, (cd $$ROOT_SRC_DIR && rsync -R $$BUILD_SYSTEM_FILES $$DIST_DIR))
	}
	addCommand(fulldist.commands, tar -czvf $$PACKAGE-$${RELEASE}.tar.gz $$PACKAGE-$$RELEASE/)
	addCommand(fulldist.commands, $(DEL_FILE) -r $$PACKAGE-$$RELEASE/)
}

########################################################################
# Definition of make maintainer-clean
#		This target should remove any file or directory generated by qmake
#		and make all. It does not remove things generated by make dist or
#		make install.
########################################################################

QMAKE_EXTRA_TARGETS += maintainer-clean

contains(TEMPLATE, subdirs) {
	maintainer-clean.CONFIG = recursive
	addCommand(maintainer-clean.commands, $(DEL_FILE) Makefile)
} else {
	# When not calling any recursive makefile: call distclean
	maintainer-clean.depends = distclean
}

# Remove the directories where we put intermediate files
!isEmpty(OBJECTS_DIR): addCommand(maintainer-clean.commands, ($(CHK_DIR_EXISTS) $$OBJECTS_DIR && $(DEL_DIR) -p $$OBJECTS_DIR; true))
!isEmpty(RCC_DIR):     addCommand(maintainer-clean.commands, ($(CHK_DIR_EXISTS) $$RCC_DIR     && $(DEL_DIR) -p $$RCC_DIR; true))
!isEmpty(MOC_DIR):     addCommand(maintainer-clean.commands, ($(CHK_DIR_EXISTS) $$MOC_DIR     && $(DEL_DIR) -p $$MOC_DIR; true))
!isEmpty(UI_DIR):      addCommand(maintainer-clean.commands, ($(CHK_DIR_EXISTS) $$UI_DIR      && $(DEL_DIR) -p $$UI_DIR; true))

# In the root makefile we destroy the directories for libraries and applications
equals(ROOT_PATH, .) {
	LOCAL_LIB_DESTDIR = $$replace(LIB_DESTDIR, ./, )
	LOCAL_APP_DESTDIR = $$replace(APP_DESTDIR, ./, )
	LOCAL_LIB_DESTDIR = $$replace(LOCAL_LIB_DESTDIR, $$ROOT_BUILD_DIR/, )
	LOCAL_APP_DESTDIR = $$replace(LOCAL_APP_DESTDIR, $$ROOT_BUILD_DIR/, )

	addCommand(maintainer-clean.commands, ($(CHK_DIR_EXISTS) $$LOCAL_LIB_DESTDIR && $(DEL_DIR) -p $$LOCAL_LIB_DESTDIR; true))
	addCommand(maintainer-clean.commands, ($(CHK_DIR_EXISTS) $$LOCAL_APP_DESTDIR && $(DEL_DIR) -p $$LOCAL_APP_DESTDIR; true))
}

# In case of out-of-source build we destroy the parallel directory hierarchy created by qmake
!equals(BUILD_DIR, $$SRC_DIR) {
	contains(TEMPLATE, subdirs) {
		# Create the list of directories
		for(dir, SUBDIRS) {
			!isEmpty($${dir}.subdir) {
				SUBDIRS_PATH += $$eval($${dir}.subdir)
			} else: !isEmpty($${dir}.file) {
				SUBDIRS_PATH += $$dirname(eval($${dir}.file))
			} else {
				SUBDIRS_PATH += $$dir
			}
		}
		addCommand(maintainer-clean.commands, $(DEL_DIR) -p $$SUBDIRS_PATH; true)
	}
}
