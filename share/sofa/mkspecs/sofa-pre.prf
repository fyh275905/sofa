########################################################################
# SOFA build system configuration
#   This file should be included at the very beginning of each pro file 
########################################################################

defineReplace(normalizePath) {
	path = $$1
	path = $$replace(path, //, /)
	path = $$replace(path, /$, )
	return($$path)
}

########################################################################
# Default options
########################################################################

CONFIG += exceptions rtti

win32 {
	QMAKE_CXXFLAGS_DEBUG = -Gm -ZI
	QMAKE_CXXFLAGS_RELEASE = -MP
}

########################################################################
# Build system path variables
#		Warning: trying to modify these variables is pointless, they just
#		describe where the build system is running.
########################################################################

FEATURES_DIR = $$normalizePath($$PWD)
BUILD_DIR = $$normalizePath($$OUT_PWD)
SRC_DIR   = $$normalizePath($$_PRO_FILE_PWD_)

## assumes this .prf file is located in $$SOFA_DIR/share/sofa/mkspecs
SOFA_DIR = $$replace(FEATURES_DIR, /\\w+/\\w+/\\w+$, )

# We could get the ROOT_BUILD_DIR on Unix using $$(PWD), but
# on Windows the equivalent $$(CD) does not work and $$system(echo %CD%)
# gives the same path as $$PWD which is not the root build directory.
# We have to compute what piece of path is common to both the BUILD_DIR
# and the SRC_DIR and deduce the root build directory.
# We have chosen to use a common approach for both platform, because it
# makes it easier to compute derivate paths: SUBDIR_PATH and ROOT_PATH.

ROOT_SRC_DIR   = $$SRC_DIR
ROOT_BUILD_DIR = $$BUILD_DIR
DIR_LIST = $$split(SRC_DIR, '/')

# We iterate on path elements.
# Each iteration will discard the last element of each path
# until they get different. At this moment the remaining paths
# will only contain the root source dir and the root build dir.
for(dir, DIR_LIST) {
	sdir = $$basename(ROOT_SRC_DIR)
	bdir = $$basename(ROOT_BUILD_DIR)
	equals(sdir, $$bdir) {
		# Prepend the directory to the path of the subdir
		isEmpty(SUBDIR_PATH): SUBDIR_PATH = $$sdir
		else:                 SUBDIR_PATH = $$sdir/$$SUBDIR_PATH
		isEmpty(ROOT_PATH):   ROOT_PATH = ..
		else:                 ROOT_PATH = $$ROOT_PATH/..
		# Remove the last element of the directory lists
		ROOT_SRC_DIR = $$dirname(ROOT_SRC_DIR)
		ROOT_BUILD_DIR = $$dirname(ROOT_BUILD_DIR)
	} else {
		break()
	}
}
isEmpty(SUBDIR_PATH): SUBDIR_PATH = .
isEmpty(ROOT_PATH): ROOT_PATH = .

#message(SOFA_DIR      $$escape_expand(\\t)= $$SOFA_DIR)
#message(ROOT_SRC_DIR  $$escape_expand(\\t)= $$ROOT_SRC_DIR)
#message(SRC_DIR       $$escape_expand(\\t)= $$SRC_DIR)
#message(ROOT_BUILD_DIR$$escape_expand(\\t)= $$ROOT_BUILD_DIR)
#message(BUILD_DIR     $$escape_expand(\\t)= $$BUILD_DIR)
#message(SUBDIR_PATH   $$escape_expand(\\t)= $$SUBDIR_PATH)
#message(ROOT_PATH     $$escape_expand(\\t)= $$ROOT_PATH)

########################################################################
# Extension point:
#		If needed, create a file name sofa-pre-custom.prf at the root of
#		your build dir (where you run qmake), and set any variable you need.
#		Values defined there will override default values.
#		If you run "make install" this file will be installed.
########################################################################

CUSTOM_FEATURES_FILE = $$ROOT_BUILD_DIR/sofa-local
INSTALLED_FEATURE_FILE = $$FEATURES_DIR/sofa-local

DEFAULT_DEPENDENCY_FILE = $$ROOT_SRC_DIR/dependencies.pri
CUSTOM_DEPENDENCY_FILE = $$ROOT_BUILD_DIR/dependencies-local.pri


exists($${CUSTOM_FEATURES_FILE}.prf) {
	load($$CUSTOM_FEATURES_FILE)
}

exists($${INSTALLED_FEATURE_FILE}.prf) {
	load($$INSTALLED_FEATURE_FILE)
}

########################################################################
# Other descriptive variables
########################################################################

contains(CONFIG, release, debug|release) {
	CONFIGDEBUG = release
} else {
	CONFIGDEBUG = debug
}

########################################################################
# Other configuration variables
########################################################################

contains(CONFIGDEBUG, debug) {
	LIBSUFFIX = d
	APPSUFFIX = d
}

########################################################################
# Definition of Qt standard paths for intermediate files
########################################################################

isEmpty(OBJECTS_DIR) {
	OBJECTS_DIR = OBJ/$$CONFIGDEBUG
}

isEmpty(RCC_DIR) {
	RCC_DIR = RCC
}

isEmpty(MOC_DIR) {
	MOC_DIR = MOC
}

#UI_DIR

########################################################################
# Definition of SOFA-specific paths
########################################################################

isEmpty(SOFA_INSTALL_ROOT) {
	SOFA_INSTALL_ROOT = /usr/local
}

isEmpty(SOFA_FEATURES_PATH) {
	SOFA_FEATURES_PATH = share/sofa/mkspecs
}

########################################################################
# Some configuration
########################################################################

isEmpty(PACKAGE) {
	PACKAGE = sofa
}

isEmpty(RELEASE) {
	RELEASE = 1.0.0
}

isEmpty(DIST_DIR) {
	DIST_DIR = $$ROOT_BUILD_DIR/$$PACKAGE-$$RELEASE
}

isEmpty(CONFIGLIBRARIES) {
	CONFIGLIBRARIES = shared
}

isEmpty(LIB_DESTDIR) {
	LIB_DESTDIR = $$ROOT_PATH/lib
}

isEmpty(APP_DESTDIR) {
	APP_DESTDIR = $$ROOT_PATH/bin
}

INSTALL_INCLUDE_DIR = $$SOFA_DIR/include/sofa
INSTALL_LIB_DIR     = $$SOFA_DIR/lib

########################################################################
# Utility functions
########################################################################

defineTest(addCommand) {
	cmdvar = $$1
	command = $$2
	isEmpty($$cmdvar) {
		$$cmdvar = $$command
	} else {
		$$cmdvar += $$escape_expand(\\n\\t)$$command
	}
	export($$cmdvar)
}

########################################################################
# Dependency management functions
########################################################################

defineTest(isProjectFile) {
	path = $$eval($$1)
	match = $$find(path, ^.+\\.pro$)
	isEmpty(match) {
		return(false)
	} else {
		return(true)
	}
}

defineTest(addSubdirs) {
	for(subdirs, 1) {
		entries = $$files($$subdirs)
		for(entry, entries) {
			name = $$replace(entry, [/\\\\\\.], _)
			SUBDIRS += $$name
			isProjectFile(entry) {
				eval  ($${name}.file = $$entry)
				export($${name}.file)
			} else {
				eval  ($${name}.subdir = $$entry)
				export($${name}.subdir)
			}

			for(dep, 2) {
				eval ($${name}.depends += $$replace(dep, [/\\\\\\.], _))
			}
			export ($${name}.depends)
		}
	}
	export (SUBDIRS)
}

##
# This functions tests whether a module is installed.
# A module is considered installed if a feature file having the specified name
# exists in the feature directory (which also contain this sofa-pre.prf file).
#
defineTest(isInstalled) {
	name = $$1
	exists($$FEATURES_DIR/$${name}.prf) {
		return (true)
	}	else {
		return (false)
	} 
}

##
# This function tests whether sources of the specified module are available.
# Sources are considered available if a project file having the specified name
# exists in the specified directory.
#
defineTest(isSourceAvailable) {
	name = $$1
	dir  = $$2
	proname = $$basename(dir)
	isProjectFile(proname) {
		dir = $$dirname(dir)
	} else {
		proname = $${proname}.pro
	}
	exists($$ROOT_SRC_DIR/$$dir/$$proname) {
		return (true)
	}	else {
		return (false)
	}
}

##
# This function activates the compilation of the specified artifact if available.
# If it is not available for compilation it looks for an installed version, and
# will complains if the artifact is missing.
#
defineTest(addInstallableSubdir) {
	name = $$1
	dir  = $$2
	deps = $$3
	isSourceAvailable($$name, $$dir) {
		addSubdirs($$dir, $$deps)
	} else {
		!isInstalled($$name) {
			error(activateLib: Cannot find $$name library)
		}
	}
}

##
# This function configures the current artifact build parameters to compile and
# link using the specified library.
# It can work either when sources are available in the same source tree as the
# client artifact, or when just the installed version is available.
#
# Parameters:
#		name	the name of the library
#		dir		the subdirectory from include tree root and/or source tree root
#
# This function makes several assumption by default to configure the include path,
# library path and library name. Nevertheless, you can customize things in the
# library feature file. This file should be named <name>.prf file and created in
# the  <dir> directory of your source tree.
# In this file, you can set MY_INCLUDEPATH, MY_LIBRARYPATH and MY_LIBS variables
# to override default values. You can also define other variables, but you
# will have to export them using export(VAR)
#
defineTest(requireLib) {
	name = $$1
	project  = $$2
	isEmpty(name)   : error(missing name parameter in requireLib)
	isEmpty(project): error(missing project parameter in requireLib)

	OLD_INCLUDEPATH = $$INCLUDEPATH
	OLD_LIBS = $$LIBS

	isProjectFile(project) {
		dir = $$dirname(project)
	} else {
		dir = $$project
	}

	isSourceAvailable($$name, $$project) {
		message(Using shipped version of $$name)
		MY_FEATUREFILE = $$ROOT_SRC_DIR/$$dir/$${name}
		MY_INCLUDEPATH = $$ROOT_SRC_DIR/$$dir
		MY_LIBRARYPATH = -L$$LIB_DESTDIR
	} else {
		!isInstalled($$name) {
			error(requireLib: Cannot find $$name library)
		}
		message(Using installed version of $$name)
		MY_FEATUREFILE = $$FEATURES_DIR/$${name}
		MY_INCLUDEPATH = $$INSTALL_INCLUDE_DIR/$$dir
		MY_LIBRARYPATH = -L$$INSTALL_LIB_DIR
	}
	MY_LIBS = -l$$name$$LIBSUFFIX

	load($$MY_FEATUREFILE)

	equals(OLD_INCLUDEPATH, $$INCLUDEPATH) {
		INCLUDEPATH *= $$MY_INCLUDEPATH
	}
	equals(OLD_LIBS, $$LIBS) {
		LIBS *= $$MY_LIBRARYPATH $$MY_LIBS
	}

	export (INCLUDEPATH)
	export (LIBS)
}

##
# This function configures the current artifact build parameters to compile and
# link using the specified SOFA library.
# It can work either when sources are available in the same source tree as the
# client artifact, or when just the installed version is available.
#
# Parameters:
#		name	the name of the library
#		dir		the subdirectory from include tree root and/or source tree root
#
defineTest(requireSofaLib) {
	name = $$1
	project = $$2
	isEmpty(name)   : error(missing name parameter in requireSofaLib)
	isEmpty(project): error(missing project parameter in requireSofaLib)

	sourcedir = $$replace(project, (applications|framework|modules)/.+, \\1)

	isSourceAvailable($$name, $$project) {
		message(Using shipped version of Sofa library: $$name)
		INCLUDEPATH *= $$ROOT_SRC_DIR/$$sourcedir
		LIBS *= -L$$LIB_DESTDIR
	} else {
		!isInstalled($$name) {
			error(requireSofaLib: Cannot find $$name library)
		}
		message(Using installed version of Sofa library: $$name)
		INCLUDEPATH *= $$INSTALL_INCLUDE_DIR/$$sourcedir
		LIBS *= -L$$INSTALL_LIB_DIR
	}
	LIBS *= -l$$name$$LIBSUFFIX

	export (INCLUDEPATH)
	export (LIBS)
}

defineTest(declare) {
	varname = $$1
	project = $$2
	dependencies = $$3

	eval($${varname}.name = $$varname)
	eval($${varname}.project = $$project)
	eval($${varname}.deps = $$dependencies)
	
	export($${varname}.name)
	export($${varname}.project)
	export($${varname}.deps)
}

defineTest(enable) {
	name = $$1
	!equals(name, $$eval($${name}.name)): error(undeclared artifact $$name)
	project = $$eval($${name}.project)
	deps = $$eval($${name}.deps)
	for(dep, deps) {
		!equals(dep, $$eval($${dep}.name)): error(undeclared dependency $$dep)
		deps_dirs += $$eval($${dep}.project)
	}
	addInstallableSubdir($$name, $$project, $$deps_dirs)
}

defineTest(loadDependencies) {
	dependencies = $$eval($${TARGET}.deps)
	for(dep, dependencies) {
		name = $$eval($${dep}.name)
		!equals(dep, $$name): error(undeclared dependency $$dep)
		project = $$eval($${dep}.project)
		sofasrc = $$find(project, ^applications|framework|modules/.+$)
		isEmpty(sofasrc) {
			requireLib($$name, $$project)
		} else {
			requireSofaLib($$name, $$project)
		}
	}
}

########################################################################
# Loading dependencies declarations
########################################################################

include($$DEFAULT_DEPENDENCY_FILE)
exists($$CUSTOM_DEPENDENCY_FILE) {
	include($$CUSTOM_DEPENDENCY_FILE)
}
